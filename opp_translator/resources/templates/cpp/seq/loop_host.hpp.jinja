{% extends "cpp/loop_host.hpp.jinja" %}

{%- macro arg_to_pointer(arg) %}
    {%- if arg is gbl %}
        {%- set cast = arg.typ -%}
        ({{cast}} *)arg{{arg.id}}.data
    {%- else -%}
        {%- set cast = lh.dat(arg).typ -%}
    
        {%- if arg is direct -%}
            {%- if lh is injected_loop -%}
            {%- set offset = "(inj_start + n)" -%}
            {%- else -%}
            {%- set offset = "n" -%}
            {%- endif -%}
        {%- elif arg is double_indirect -%}
            {%- set offset = "map%s[%d]" % (arg.map_id, arg.map_idx) -%}
        {%- elif arg is p2c_mapped -%}
            {%- set offset = "map_p2c" -%}
        {%- elif arg is indirect -%}
            {%- set offset = "map%s[%d]" % (arg.map_id, arg.map_idx) -%}
        {%- endif -%}

        {%- if arg is not gbl %}
            {%- set offset = " + (%s * %d)" % (offset, lh.dat(arg).dim) %}
        {%- endif -%}

        {%- if lh is indirect and arg is gbl and arg is reduction %}
            arg{{arg.id}}_local
        {%- else -%}
            ({{"const " if arg.access_type == OP.AccessType.READ}}{{cast}} *)args[{{arg.id}}].data{{offset}}
        {%- endif -%}
    {%- endif -%}
{%- endmacro -%}

{% block host_prologue %}
{{super()}}
    {% for arg in lh.args|gbl|reduction if lh is indirect %}
    {{arg.typ}} arg{{arg.id}}_local[{{arg.dim}}] = {0};{{"\n" if loop.last}}
    {% endfor %}
    {% for arg in lh.args|gbl|reduction if lh is indirect and arg is not inc %}
    memcpy(arg{{arg.id}}_local, arg{{idx}}.data, {{arg.dim}} * sizeof({{arg.typ}}));{{"\n" if loop.last}}
    {% endfor %}
{% endblock %}

{% block host_loop %}
    for (int n = 0; n < iter_size; ++n) 
    {
    {% if lh is not particle_loop %}
        if (n == set->core_size)
            opp_mpi_halo_wait_all{{"_grouped" if config.grouped-}}
                (nargs, args{{", 1" if config.grouped}});

    {% endif %}
    {% if lh is indirect %}
        {% if lh is p2c_mapped %}
        {% if lh is injected_loop %}
        const OPP_INT map_p2c = OPP_mesh_relation_data[inj_start + n];
        {% else %}
        const OPP_INT map_p2c = OPP_mesh_relation_data[n];
        {% endif %}
        {% endif %}
        {% for map in lh.maps %}
        {%- if map is not p2c_mapped(lh) -%}
            {%- set offset = "n" -%}
        {%- else -%}
            {%- set offset = "map_p2c" -%}
        {%endif %}
        OPP_INT *map{{map.id}} = arg{{map.arg_id}}.map_data + {{ offset }} * arg{{map.arg_id}}.map->dim;
        {% endfor %}   
    {% endif %}
    {% for arg in lh.args|vec %}
        {{"const " if arg.access_type == OP.AccessType.READ}}{{lh.dat(arg).typ}} *args{{arg.id}}_vec[] = {
        {% for arg_expanded in lh.args if arg_expanded.id == arg.id %}
            {{arg_to_pointer(arg_expanded)}}{{"," if not loop.last}}
        {% endfor %}
        };

    {% endfor %}
    {% if lh is indirect and lh.args|gbl|reduction|length > 0 %}
        if (n == set->size) {
        {% for arg in lh.args|gbl|reduction %}
            memcpy(arg{{arg.id}}.data, arg{{arg.id}}_local, {{arg.dim}} * sizeof({{arg.typ}}));
        {% endfor %}
        }

    {% endif %}
        opp_k{{kernel_idx}}::{{lh.kernel}}(
    {% for arg in lh.args %}
        {% if arg is not vec %}
            {{arg_to_pointer(arg)}}{{"," if not loop.last}}
        {% else %}
            arg{{arg.id}}_vec{{"," if not loop.last}}
        {% endif %}
    {% endfor %}
        );
    {#
    #}
    }
{% endblock %}

{% block host_epilogue %}
    {% if lh is not particle_loop -%} {# TODO: is this indirect check necessary? #}
    if (iter_size == 0 || iter_size == set->core_size)
        opp_mpi_halo_wait_all(nargs, args);

    {% endif %}
    {% for arg in lh.args|gbl|reduction %}
    opp_mpi_reduce_double(&arg{{arg.id}}, ({{arg.typ}} *)arg{{arg.id}}.data);
    {% endfor %}
    opp_set_dirtybit(nargs, args);

{{super()}}
{% endblock %}
